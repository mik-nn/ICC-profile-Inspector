<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>ICC Inspector</title>
<style>
  body { font-family: monospace; background: #f5f5f5; margin: 0; padding: 20px; }
  .container { max-width: 1000px; margin: auto; background: white; padding: 20px; border-radius: 8px; }
  input[type=file] { margin: 10px 0; }
  summary { font-weight: bold; cursor: pointer; }
  ul { list-style: none; padding-left: 20px; }
  pre { background: #222; color: #0f0; padding: 10px; border-radius: 5px; overflow-x: auto; white-space: pre; }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
<script src="utils.js"></script>
<script src="parse.js"></script>
<script src="view.js"></script>
</head>
<body>
<div class="container">
  <h1 id="title">ICC Inspector</h1>
  <label>Выберите JSON‑схему:</label><br>
  <input type="file" id="schemaInput" accept=".json"><br>
  <label>Выберите ICC‑профиль:</label><br>
  <input type="file" id="iccInput" accept=".icc,.icm,application/vnd.iccprofile" disabled><br>
  <div id="output">Сначала выберите схему...</div>
</div>

<script>
let schemaMap = {};
let schemaResolved = {};

document.getElementById('schemaInput').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    try {
      schemaMap = JSON.parse(reader.result);
      schemaResolved = {};
      document.getElementById('iccInput').disabled = false;
      document.getElementById('output').textContent = 'Схема загружена. Теперь выберите ICC‑файл.';
    } catch (err) {
      document.getElementById('output').textContent = 'Ошибка чтения схемы: ' + err;
    }
  };
  reader.readAsText(file);
});

document.getElementById('iccInput').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  document.getElementById('title').textContent = file.name;
  const reader = new FileReader();
  reader.onload = () => {
    const buffer = reader.result;
    const view = new DataView(buffer);

    let header = {};
    if (schemaMap['ICCHeader']) {
      header = api_parseBySchema(view, api_resolveSchema('ICCHeader'), 0);
    }

    const tagCount = view.getUint32(128, false);
    const tags = [];
    let tagTableOffset = 132;
    for (let i = 0; i < tagCount; i++) {
      const sig = readAscii(view, tagTableOffset, 4);
      const off = view.getUint32(tagTableOffset+4, false);
      const size = view.getUint32(tagTableOffset+8, false);
      tags.push({ tagSignature: sig, offset: off, size });
      tagTableOffset += 12;
    }

    const parsedTags = {};
    for (const tag of tags) {
  const schema = api_pickSchema(tag.tagSignature, view, tag.offset);
      let tagTitle = `${tag.tagSignature} [offset: ${tag.offset}, length: ${tag.size}]`;
      if (schema) {
        try {
          const ctx = { tagSize: tag.size };
          let parsed = api_parseBySchema(view, schema, tag.offset, ctx);


          // Special handling for ZXML and CxF: detect by type signature or tag signature
          try {
            const typeSig = api_readAscii(view, tag.offset, 4);
            if (typeSig === 'ZXML' || tag.tagSignature === 'CxF ') {
              // prefer parsed.compressedData or parsed.bytes if available
              let bytes = (parsed && parsed.compressedData) ? parsed.compressedData : (parsed && parsed.bytes) ? parsed.bytes : null;
              // if not parsed, take raw payload after the 8-byte header (typeSignature + reserved)
              if (!bytes) {
                try {
                  const start = tag.offset + 8;
                  const len = Math.max(0, tag.size - 8);
                  bytes = new Uint8Array(buffer, start, len);
                } catch (e) {
                  bytes = null;
                }
              }
              if (bytes) {
                try {
                  // For ZXML content: first 12 bytes are: ZXML + 8 zeros + 2-byte version
                  const isZXML = bytes.length >= 4 && 
                    bytes[0] === 0x5A && // 'Z'
                    bytes[1] === 0x58 && // 'X'
                    bytes[2] === 0x4D && // 'M'
                    bytes[3] === 0x4C;   // 'L'
                  
                  // Skip ZXML 12-byte header if present
                  if (isZXML && bytes.length >= 12) {
                    bytes = bytes.slice(12);
                  }

                  let inflated;
                  try {
                    // Inflate the zlib-compressed data (which starts with 0x78 0x9C)
                    inflated = pako.inflate(bytes, { to: 'string' });
                  } catch (e) {
                    parsed.decompressedXML = `Ошибка распаковки: ${e}. First bytes: ${Array.from(bytes.slice(0,16)).map(b => b.toString(16).padStart(2,'0')).join(' ')}`;
                    return;
                  }
                  // Try parse XML and render as tree
                  let xmlTree = null;
                  try {
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(inflated, 'application/xml');
                    xmlTree = renderXMLTree(xmlDoc.documentElement);
                  } catch (e) {
                    xmlTree = `<pre>${inflated}</pre>`;
                  }
                  parsed.decompressedXML = xmlTree;
                } catch (e) {
                  parsed.decompressedXML = 'Ошибка распаковки: ' + e;
                }
              }
            }
          } catch (e) {
            // ignore read errors
          }
            // Special handling for matrix3x3Type (e.g., chad)
            if (schema && schema.name === 'matrix3x3Type') {
              try {
                if (window.renderMatrix3x3) parsed.__table = window.renderMatrix3x3(parsed);
              } catch (e) {
                // ignore render errors
              }
            }
            // Fallback: if schema wasn't detected but tag is literally 'chad', render matrix
            if ((!schema || schema.name !== 'matrix3x3Type') && tag.tagSignature === 'chad') {
              try {
                if (window.renderMatrix3x3) parsed.__table = window.renderMatrix3x3(parsed);
              } catch (e) {
                // ignore
              }
            }


          // Special handling for text-like tags (textType, descType, cprt, DevD)
          let formattedText = null;
          if (schema && schema.name === 'textType' && parsed.text) formattedText = parsed.text;
          else if (schema && schema.name === 'descType' && parsed.asciiString) formattedText = parsed.asciiString;
          else if (parsed && parsed.asciiString) formattedText = parsed.asciiString;
          else if (parsed && parsed.text) formattedText = parsed.text;
          // If we found text content, render as escaped preformatted block
          if (formattedText !== null) {
            const clean = window.sanitizeText ? window.sanitizeText(formattedText) : String(formattedText).trim();
            const esc = window.escapeHTML ? window.escapeHTML(clean) : String(clean);
            parsedTags[tagTitle] = { text: `<pre style='background:#fff;color:#222;padding:10px;border-radius:5px;white-space:pre-wrap;'>${esc}</pre>` };
          } else {
            parsedTags[tagTitle] = parsed;
          }
        } catch (err) {
          parsedTags[tagTitle] = { error: String(err), rawHex: api_formatHexDump(new Uint8Array(buffer, tag.offset, tag.size), tag.offset) };
        }
      } else {
        // No schema: try to special-case CxF which often contains ZXML data
        if (tag.tagSignature === 'CxF ') {
          try {
            // Read first few bytes to check ZXML signature
            const bytes = new Uint8Array(buffer, tag.offset, tag.size);
            // Look for ZXML signature
            if (bytes.length >= 12 && 
                bytes[0] === 0x5A && bytes[1] === 0x58 && 
                bytes[2] === 0x4D && bytes[3] === 0x4C) {
              // Skip ZXML header (12 bytes) and inflate
              const zlibData = new Uint8Array(buffer, tag.offset + 12, tag.size - 12);
              try {
                const inflated = pako.inflate(zlibData, { to: 'string' });
                // Parse inflated XML
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(inflated, 'application/xml');
                const xmlTree = renderXMLTree(xmlDoc.documentElement);
                parsedTags[tagTitle] = { decompressedXML: xmlTree };
              } catch (e) {
                // Show inflation error with debug info
                parsedTags[tagTitle] = { 
                  error: `Ошибка распаковки ZXML: ${e}`,
                  debug: `First bytes after ZXML header: ${Array.from(zlibData.slice(0,16)).map(b => b.toString(16).padStart(2,'0')).join(' ')}`
                };
              }
            } else {
              // Not ZXML, show raw hex
              parsedTags[tagTitle] = { rawHex: api_formatHexDump(bytes, tag.offset) };
            }
          } catch (e) {
            // fallback to raw hex dump
            parsedTags[tagTitle] = { rawHex: api_formatHexDump(new Uint8Array(buffer, tag.offset, tag.size), tag.offset) };
          }
        } else {
          parsedTags[tagTitle] = { rawHex: api_formatHexDump(new Uint8Array(buffer, tag.offset, tag.size), tag.offset) };
        }
      }
    }

    const result = { Header: header, Tags: parsedTags };
    const out = document.getElementById('output');
    out.innerHTML = '';
  out.appendChild(api_renderTree(result, file.name, true));
  };
  reader.readAsArrayBuffer(file);
});


// Use pickSchema from parse.js
const api_pickSchema = (tagSig, view, offset) => window.pickSchema(tagSig, view, offset, schemaMap, schemaResolved);


// Use resolveSchema from parse.js
const api_resolveSchema = (key) => window.resolveSchema(key, schemaMap, schemaResolved);


// Use parseBySchema from parse.js
const api_parseBySchema = (view, schema, startOffset=0, ctx={}) => window.parseBySchema(view, schema, startOffset, ctx);


// Use readAscii from utils.js
const api_readAscii = (view, off, len) => window.readAscii(view, off, len);


// Use formatHexDump from utils.js
const api_formatHexDump = (uint8arr, base=0) => window.formatHexDump(uint8arr, base);


// Use renderTree from view.js
const api_renderTree = (obj, label, isRoot=false) => window.renderTree(obj, label, isRoot);
</script>
</body>
</html>
