<!DOCTYPE html>
<html lang="ru">
<head>
<div class="max-w-3xl mx-auto bg-white shadow-lg rounded-lg p-6 mt-8">
  <h1 id="title" class="text-3xl font-bold mb-4 text-blue-700">ICC Inspector</h1>
  <div class="mb-4">
    <label class="block font-semibold mb-1">Выберите JSON‑схему:</label>
    <input type="file" id="schemaInput" accept=".json" class="block w-full text-sm text-gray-700 border border-gray-300 rounded p-2" />
  </div>
  <div class="mb-4">
    <label class="block font-semibold mb-1">Выберите ICC‑профиль:</label>
    <input type="file" id="iccInput" accept=".icc,.icm,application/vnd.iccprofile" disabled class="block w-full text-sm text-gray-700 border border-gray-300 rounded p-2" />
  </div>
  <div id="output" class="mt-6 text-gray-700">Сначала выберите схему...</div>
</div>
  pre { background: #222; color: #0f0; padding: 10px; border-radius: 5px; overflow-x: auto; white-space: pre; }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
</head>
      if (schema) {
        try {
          const ctx = { tagSize: tag.size };
          let parsed = parseBySchema(view, schema, tag.offset, ctx);

          // Special handling for ZXML and CxF
          if (schema.name === "zxmlType" || tag.tagSignature === "CxF ") {
            let bytes = parsed.compressedData || parsed.bytes;
            if (bytes) {
              try {
                const inflated = pako.inflate(bytes, { to: 'string' });
                let xmlTree = null;
                try {
                  const parser = new DOMParser();
                  const xmlDoc = parser.parseFromString(inflated, "application/xml");
                  xmlTree = renderXMLTree(xmlDoc.documentElement);
                } catch (e) {
                  xmlTree = `<pre>${inflated}</pre>`;
                }
                parsed.decompressedXML = xmlTree;
              } catch (e) {
                parsed.decompressedXML = "Ошибка распаковки: " + e;
              }
            }
          }

          // Special handling for chad tag: format as matrix
          if (tag.tagSignature === 'chad' && schema.name === 'matrix3x3Type') {
            parsed.matrix = { __html: renderMatrix3x3(parsed) };
          }

          // Special handling for mAB/mBA tags: decode structure
          if (["mAB ", "mBA ", "A2B0", "A2B1", "A2B2", "B2A0", "B2A1", "B2A2"].includes(tag.tagSignature)) {
            parsed.decoded = decodeMab(parsed);
          }

          // Special handling for textType
          if (schema.name === "textType") {
            parsedTags[tagTitle] = { text: `<pre>${parsed.text}</pre>` };
          } else {
            parsedTags[tagTitle] = parsed;
          }
        } catch (err) {
          parsedTags[tagTitle] = { error: String(err), rawHex: formatHexDump(new Uint8Array(buffer, tag.offset, tag.size)) };
        }
      } else {
        parsedTags[tagTitle] = { rawHex: formatHexDump(new Uint8Array(buffer, tag.offset, tag.size)) };
      }
// Render 3x3 matrix as HTML table
function renderMatrix3x3(obj) {
  if (!('m00' in obj)) return '';
  let html = '<table style="border-collapse:collapse;margin:5px 0;">';
  for (let r = 0; r < 3; r++) {
    html += '<tr>';
    for (let c = 0; c < 3; c++) {
      html += `<td style="border:1px solid #ccc;padding:2px 6px;">${obj[`m${r}${c}`]}</td>`;
    }
    html += '</tr>';
  }
  html += '</table>';
  return html;
}

// Decode mAB/mBA tags for easier viewing
function decodeMab(obj) {
  const out = {};
  if ('inputChannels' in obj) out['Input Channels'] = obj.inputChannels;
  if ('outputChannels' in obj) out['Output Channels'] = obj.outputChannels;
  if (obj.Bcurves) out['B Curves'] = obj.Bcurves;
  if (obj.Matrix) out['Matrix'] = obj.Matrix;
  if (obj.Mcurves) out['M Curves'] = obj.Mcurves;
  if (obj.CLUT) out['CLUT'] = obj.CLUT;
  if (obj.Acurves) out['A Curves'] = obj.Acurves;
  return out;
}
    let header = {};
    if (schemaMap['ICCHeader']) {
      header = parseBySchema(view, resolveSchema('ICCHeader'), 0);
    }

    const tagCount = view.getUint32(128, false);
    const tags = [];
    let tagTableOffset = 132;
    for (let i = 0; i < tagCount; i++) {
      const sig = readAscii(view, tagTableOffset, 4);
      const off = view.getUint32(tagTableOffset+4, false);
      const size = view.getUint32(tagTableOffset+8, false);
      tags.push({ tagSignature: sig, offset: off, size });
      tagTableOffset += 12;
    }

    const parsedTags = {};
    for (const tag of tags) {
      const schema = pickSchema(tag.tagSignature, view, tag.offset);
      let tagTitle = `${tag.tagSignature} [offset: ${tag.offset}, length: ${tag.size}]`;
      if (schema) {
        try {
          const ctx = { tagSize: tag.size };
          let parsed = parseBySchema(view, schema, tag.offset, ctx);


          // Special handling for ZXML and CxF
          if (schema.name === "zxmlType" || tag.tagSignature === "CxF ") {
            // Try decompress and parse XML
            let bytes = parsed.compressedData || parsed.bytes;
            if (bytes) {
              try {
                const inflated = pako.inflate(bytes, { to: 'string' });
                // Try parse XML and render as tree
                let xmlTree = null;
                try {
                  const parser = new DOMParser();
                  const xmlDoc = parser.parseFromString(inflated, "application/xml");
                  xmlTree = renderXMLTree(xmlDoc.documentElement);
                } catch (e) {
                  xmlTree = `<pre>${inflated}</pre>`;
                }
                parsed.decompressedXML = xmlTree;
              } catch (e) {
                parsed.decompressedXML = "Ошибка распаковки: " + e;
              }
            }
          }
// Render XML DOM as tree
function renderXMLTree(node) {
  if (!node) return '';
  if (node.nodeType === 3) { // text
    const text = node.nodeValue.trim();
    if (!text) return '';
    return document.createTextNode(text);
  }
  const details = document.createElement('details');
  details.open = false;
  const summary = document.createElement('summary');
  summary.textContent = `<${node.nodeName}>` + (node.attributes && node.attributes.length ?
    Array.from(node.attributes).map(a => ` ${a.name}="${a.value}"`).join('') : '');
  details.appendChild(summary);
  const ul = document.createElement('ul');
  for (let i = 0; i < node.childNodes.length; i++) {
    const child = node.childNodes[i];
    const li = document.createElement('li');
    const rendered = renderXMLTree(child);
    if (rendered) li.appendChild(rendered);
    ul.appendChild(li);
  }
  details.appendChild(ul);
  return details;
}

          // Special handling for textType
          if (schema.name === "textType") {
            parsedTags[tagTitle] = { text: `<pre>${parsed.text}</pre>` };
          } else {
            parsedTags[tagTitle] = parsed;
          }
        } catch (err) {
          parsedTags[tagTitle] = { error: String(err), rawHex: formatHexDump(new Uint8Array(buffer, tag.offset, tag.size)) };
        }
      } else {
        parsedTags[tagTitle] = { rawHex: formatHexDump(new Uint8Array(buffer, tag.offset, tag.size)) };
      }
    }

    // Compose a tree: Profile Name, Header (expanded), and Tags (list)
    const out = document.getElementById('output');
    out.innerHTML = '';

    // Profile name
    const nameDiv = document.createElement('div');
    nameDiv.className = 'text-xl font-bold text-blue-600 mb-2';
    nameDiv.textContent = file.name;
    out.appendChild(nameDiv);

    // Header (expanded)
    const headerTree = renderTree(header, 'Header', true);
    headerTree.classList.add('mb-4');
    out.appendChild(headerTree);

    // Tags list
    const tagsTitle = document.createElement('div');
    tagsTitle.className = 'text-lg font-semibold text-gray-800 mt-4 mb-2';
    tagsTitle.textContent = 'Tags';
    out.appendChild(tagsTitle);

    const tagsList = document.createElement('div');
    for (const tag in parsedTags) {
      tagsList.appendChild(renderTree(parsedTags[tag], tag, false));
    }
    out.appendChild(tagsList);
  };
  reader.readAsArrayBuffer(file);
});

function pickSchema(tagSig, view, offset) {
  if (schemaMap[tagSig]) return resolveSchema(tagSig);
  const typeSig = readAscii(view, offset, 4);
  if (schemaMap[typeSig]) return resolveSchema(typeSig);
  // mft1/mft2 special handling: ICC spec uses 'mft1' for lut8Type, 'mft2' for lut16Type
  if (typeSig === 'mft1') return resolveSchema('mft1');
  if (typeSig === 'mft2') return resolveSchema('mft2');
  // chad tag: matrix3x3Type
  if (tagSig === 'chad' || typeSig === 'chad') return resolveSchema('matrix3x3Type');
  if (["text", "desc", "mluc", "XYZ ", "curv", "ZXML"].includes(typeSig)) {
    return resolveSchema(typeSig);
  }
  return null;
}

function resolveSchema(key) {
  if (schemaResolved[key]) return schemaResolved[key];
  const raw = schemaMap[key];
  if (!raw) return null;
  if (raw.$ref) return resolveSchema(raw.$ref);
  schemaResolved[key] = raw;
  return raw;
}

function parseBySchema(view, schema, startOffset=0, ctx={}) {
  let offset = startOffset;
  const res = {};
  for (const f of schema.fields) {
    if (f.enum && f.type.startsWith('u')) {
      const raw = view.getUint32(offset, false);
      res[f.name] = raw + " (" + (f.enum[raw] || "Unknown") + ")";
      offset += 4;
      continue;
    }
    if (f.bitflags && f.type === 'u32') {
      const raw = view.getUint32(offset, false);
      const setFlags = [];
      for (const bit in f.bitflags) {
        if (raw & (1 << bit)) setFlags.push(f.bitflags[bit]);
      }
      res[f.name] = raw + (setFlags.length ? " [" + setFlags.join(', ') + "]" : "");
      offset += 4;
      continue;
    }
    if (f.type === 'string') {
      let len = f.length || 0;
      if (f.lengthField && f.lengthField === "remaining") {
        len = (ctx.tagSize || 0) - (offset - startOffset);
      } else if (f.lengthField && res[f.lengthField] !== undefined) {
        len = res[f.lengthField];
      }
      res[f.name] = readAscii(view, offset, len);
      offset += len;
    } else if (f.type === 'u8') {
      res[f.name] = view.getUint8(offset); offset += 1;
    } else if (f.type === 'u16') {
      res[f.name] = view.getUint16(offset, false); offset += 2;
    } else if (f.type === 'u32') {
      res[f.name] = view.getUint32(offset, false); offset += 4;
    } else if (f.type === 's15Fixed16') {
      res[f.name] = view.getInt32(offset, false) / 65536; offset += 4;
    } else if (f.type === 'bytes') {
      let len = f.length || 0;
      if (f.lengthField && f.lengthField === "remaining") {
        len = (ctx.tagSize || 0) - (offset - startOffset);
      }
      const bytes = new Uint8Array(view.buffer, offset, len);
      res[f.name] = bytes;
      offset += len;
    }
  }
  return res;
}

function readAscii(view, off, len) {
  return Array.from({length: len}, (_, i) => String.fromCharCode(view.getUint8(off + i))).join('');
}

function formatHexDump(uint8arr) {
  let lines = '';
  for (let i = 0; i < uint8arr.length; i += 16) {
    let hex = '';
    let ascii = '';
    for (let j = 0; j < 16; j++) {
      if (i + j < uint8arr.length) {
        const b = uint8arr[i + j];
        hex += b.toString(16).padStart(2, '0') + ' ';
        ascii += (b >= 32 && b <= 126) ? String.fromCharCode(b) : '.';
      } else {
        hex += '   ';
        ascii += ' ';
      }
    }
    lines += hex + ' | ' + ascii + '\n';
  }
  return `<pre>${lines}</pre>`;
}

function renderTree(obj, label, isRoot=false) {
  if (obj === null || typeof obj !== 'object') {
    return document.createTextNode(String(obj));
  }
  // Special case: render HTML string for matrix3x3Type
  if (obj && typeof obj === 'object' && obj.__html) {
    const wrapper = document.createElement('div');
    wrapper.innerHTML = obj.__html;
    return wrapper;
  }
  const details = document.createElement('details');
  details.open = isRoot; // только корень открыт по умолчанию
  if (label) {
    const summary = document.createElement('summary');
    summary.textContent = label;
    details.appendChild(summary);
  }
  const ul = document.createElement('ul');
  for (const key in obj) {
    const li = document.createElement('li');
    if (typeof obj[key] === 'object' && obj[key] !== null) {
      li.appendChild(renderTree(obj[key], key, false));
    } else {
      // Если значение уже содержит HTML (<pre> для текста/XML)
      if (typeof obj[key] === 'string' && obj[key].startsWith('<pre>')) {
        li.innerHTML = `<strong>${key}:</strong> ${obj[key]}`;
      } else {
        li.innerHTML = `<strong>${key}:</strong> ${obj[key]}`;
      }
    }
    ul.appendChild(li);
  }
  details.appendChild(ul);
  return details;
}
</script>
</body>
</html>
