<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>ICC Inspector</title>
<style>
  body { font-family: monospace; background: #f5f5f5; margin: 0; padding: 20px; }
  .container { max-width: 1000px; margin: auto; background: white; padding: 20px; border-radius: 8px; }
  input[type=file] { margin: 10px 0; }
  summary { font-weight: bold; cursor: pointer; }
  ul { list-style: none; padding-left: 20px; }
  pre { background: #222; color: #0f0; padding: 10px; border-radius: 5px; overflow-x: auto; white-space: pre; }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
</head>
<body>
<div class="container">
  <h1 id="title">ICC Inspector</h1>
  <label>Выберите JSON‑схему:</label><br>
  <input type="file" id="schemaInput" accept=".json"><br>
  <label>Выберите ICC‑профиль:</label><br>
  <input type="file" id="iccInput" accept=".icc,.icm,application/vnd.iccprofile" disabled><br>
  <div id="output">Сначала выберите схему...</div>
</div>

<script>
let schemaMap = {};
let schemaResolved = {};

document.getElementById('schemaInput').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    try {
      schemaMap = JSON.parse(reader.result);
      schemaResolved = {};
      document.getElementById('iccInput').disabled = false;
      document.getElementById('output').textContent = 'Схема загружена. Теперь выберите ICC‑файл.';
    } catch (err) {
      document.getElementById('output').textContent = 'Ошибка чтения схемы: ' + err;
    }
  };
  reader.readAsText(file);
});

document.getElementById('iccInput').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  document.getElementById('title').textContent = file.name;
  const reader = new FileReader();
  reader.onload = () => {
    const buffer = reader.result;
    const view = new DataView(buffer);

    let header = {};
    if (schemaMap['ICCHeader']) {
      header = parseBySchema(view, resolveSchema('ICCHeader'), 0);
    }

    const tagCount = view.getUint32(128, false);
    const tags = [];
    let tagTableOffset = 132;
    for (let i = 0; i < tagCount; i++) {
      const sig = readAscii(view, tagTableOffset, 4);
      const off = view.getUint32(tagTableOffset+4, false);
      const size = view.getUint32(tagTableOffset+8, false);
      tags.push({ tagSignature: sig, offset: off, size });
      tagTableOffset += 12;
    }

    const parsedTags = {};
    for (const tag of tags) {
      const schema = pickSchema(tag.tagSignature, view, tag.offset);
      if (schema) {
        try {
          const ctx = { tagSize: tag.size };
          const parsed = parseBySchema(view, schema, tag.offset, ctx);

          // Обработка ZXML
          if (schema.name === "zxmlType") {
            const bytes = parsed.compressedData;
            try {
              const inflated = pako.inflate(bytes, { to: 'string' });
              parsed.decompressedXML = `<pre>${inflated}</pre>`;
            } catch (e) {
              parsed.decompressedXML = "Ошибка распаковки: " + e;
            }
          }

          // Обработка textType
          if (schema.name === "textType") {
            parsedTags[tag.tagSignature] = { text: `<pre>${parsed.text}</pre>`, offset: tag.offset, length: tag.size };
          } else {
            parsedTags[tag.tagSignature] ={ parsed, offset: tag.offset, length: tag.size};
          }
        } catch (err) {
          parsedTags[tag.tagSignature] = { error: String(err), rawHex: formatHexDump(new Uint8Array(buffer, tag.offset, tag.size)) };
        }
      } else {
        parsedTags[tag.tagSignature] = { rawHex: formatHexDump(new Uint8Array(buffer, tag.offset, tag.size)) };
      }
    }

    const result = { Header: header, Tags: parsedTags };
    const out = document.getElementById('output');
    out.innerHTML = '';
    out.appendChild(renderTree(result, file.name, true));
  };
  reader.readAsArrayBuffer(file);
});

function pickSchema(tagSig, view, offset) {
  if (schemaMap[tagSig]) return resolveSchema(tagSig);
  const typeSig = readAscii(view, offset, 4);
  if (schemaMap[typeSig]) return resolveSchema(typeSig);
  if (["text", "desc", "mluc", "XYZ ", "curv", "ZXML"].includes(typeSig)) {
    return resolveSchema(typeSig);
  }
  return null;
}

function resolveSchema(key) {
  if (schemaResolved[key]) return schemaResolved[key];
  const raw = schemaMap[key];
  if (!raw) return null;
  if (raw.$ref) return resolveSchema(raw.$ref);
  schemaResolved[key] = raw;
  return raw;
}

function parseBySchema(view, schema, startOffset=0, ctx={}) {
  let offset = startOffset;
  const res = {};
  for (const f of schema.fields) {
    if (f.enum && f.type.startsWith('u')) {
      const raw = view.getUint32(offset, false);
      res[f.name] = raw + " (" + (f.enum[raw] || "Unknown") + ")";
      offset += 4;
      continue;
    }
    if (f.bitflags && f.type === 'u32') {
      const raw = view.getUint32(offset, false);
      const setFlags = [];
      for (const bit in f.bitflags) {
        if (raw & (1 << bit)) setFlags.push(f.bitflags[bit]);
      }
      res[f.name] = raw + (setFlags.length ? " [" + setFlags.join(', ') + "]" : "");
      offset += 4;
      continue;
    }
    if (f.type === 'string') {
      let len = f.length || 0;
      if (f.lengthField && f.lengthField === "remaining") {
        len = (ctx.tagSize || 0) - (offset - startOffset);
      } else if (f.lengthField && res[f.lengthField] !== undefined) {
        len = res[f.lengthField];
      }
      res[f.name] = readAscii(view, offset, len);
      offset += len;
    } else if (f.type === 'u8') {
      res[f.name] = view.getUint8(offset); offset += 1;
    } else if (f.type === 'u16') {
      res[f.name] = view.getUint16(offset, false); offset += 2;
    } else if (f.type === 'u32') {
      res[f.name] = view.getUint32(offset, false); offset += 4;
    } else if (f.type === 's15Fixed16') {
      res[f.name] = view.getInt32(offset, false) / 65536; offset += 4;
    } else if (f.type === 'bytes') {
      let len = f.length || 0;
      if (f.lengthField && f.lengthField === "remaining") {
        len = (ctx.tagSize || 0) - (offset - startOffset);
      }
      const bytes = new Uint8Array(view.buffer, offset, len);
      res[f.name] = bytes;
      offset += len;
    }
  }
  return res;
}

function readAscii(view, off, len) {
  return Array.from({length: len}, (_, i) => String.fromCharCode(view.getUint8(off + i))).join('');
}

function formatHexDump(uint8arr) {
  let lines = '';
  for (let i = 0; i < uint8arr.length; i += 16) {
    let hex = '';
    let ascii = '';
    for (let j = 0; j < 16; j++) {
      if (i + j < uint8arr.length) {
        const b = uint8arr[i + j];
        hex += b.toString(16).padStart(2, '0') + ' ';
        ascii += (b >= 32 && b <= 126) ? String.fromCharCode(b) : '.';
      } else {
        hex += '   ';
        ascii += ' ';
      }
    }
    lines += hex + ' | ' + ascii + '\n';
  }
  return `<pre>${lines}</pre>`;
}

function renderTree(obj, label, isRoot=false) {
  if (obj === null || typeof obj !== 'object') {
    return document.createTextNode(String(obj));
  }
  const details = document.createElement('details');
  details.open = isRoot; // только корень открыт по умолчанию
  if (label) {
    const summary = document.createElement('summary');
    summary.textContent = label;
    details.appendChild(summary);
  }
  const ul = document.createElement('ul');
  for (const key in obj) {
    const li = document.createElement('li');
    if (typeof obj[key] === 'object' && obj[key] !== null) {
      li.appendChild(renderTree(obj[key], key, false));
    } else {
      // Если значение уже содержит HTML (<pre> для текста/XML)
      if (typeof obj[key] === 'string' && obj[key].startsWith('<pre>')) {
        li.innerHTML = `<strong>${key}:</strong> ${obj[key]}`;
      } else {
        li.innerHTML = `<strong>${key}:</strong> ${obj[key]}`;
      }
    }
    ul.appendChild(li);
  }
  details.appendChild(ul);
  return details;
}
</script>
</body>
</html>
