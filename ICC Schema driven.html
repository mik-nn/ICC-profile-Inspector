<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>ICC Inspector</title>
<style>
  body { font-family: monospace; background: #f5f5f5; margin: 0; padding: 20px; }
  .container { max-width: 1000px; margin: auto; background: white; padding: 20px; border-radius: 8px; }
  input[type=file] { margin: 10px 0; }
  summary { font-weight: bold; cursor: pointer; }
  ul { list-style: none; padding-left: 20px; }
  pre { background: #222; color: #0f0; padding: 10px; border-radius: 5px; overflow-x: auto; white-space: pre; }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
<script src="utils.js"></script>
<script src="parse.js"></script>
<script src="view.js"></script>
</head>
<body>
<div class="container">
  <h1 id="title">ICC Inspector</h1>
  <label>Выберите JSON‑схему:</label><br>
  <input type="file" id="schemaInput" accept=".json"><br>
  <label>Выберите ICC‑профиль:</label><br>
  <input type="file" id="iccInput" accept=".icc,.icm,application/vnd.iccprofile" disabled><br>
  <div id="output">Сначала выберите схему...</div>
</div>

<script>
let schemaMap = {};
let schemaResolved = {};

document.getElementById('schemaInput').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    try {
      schemaMap = JSON.parse(reader.result);
      schemaResolved = {};
      document.getElementById('iccInput').disabled = false;
      document.getElementById('output').textContent = 'Схема загружена. Теперь выберите ICC‑файл.';
    } catch (err) {
      document.getElementById('output').textContent = 'Ошибка чтения схемы: ' + err;
    }
  };
  reader.readAsText(file);
});

document.getElementById('iccInput').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  document.getElementById('title').textContent = file.name;
  const reader = new FileReader();
  reader.onload = () => {
    const buffer = reader.result;
    const view = new DataView(buffer);

    let header = {};
    if (schemaMap['ICCHeader']) {
      header = api_parseBySchema(view, api_resolveSchema('ICCHeader'), 0);
    }

    const tagCount = view.getUint32(128, false);
    const tags = [];
    let tagTableOffset = 132;
    for (let i = 0; i < tagCount; i++) {
      const sig = readAscii(view, tagTableOffset, 4);
      const off = view.getUint32(tagTableOffset+4, false);
      const size = view.getUint32(tagTableOffset+8, false);
      tags.push({ tagSignature: sig, offset: off, size });
      tagTableOffset += 12;
    }

    const parsedTags = {};
    for (const tag of tags) {
  const schema = api_pickSchema(tag.tagSignature, view, tag.offset);
      let tagTitle = `${tag.tagSignature} [offset: ${tag.offset}, length: ${tag.size}]`;
      if (schema) {
        try {
          const ctx = { tagSize: tag.size };
          let parsed = api_parseBySchema(view, schema, tag.offset, ctx);


          // Special handling for ZXML and CxF
          if (schema.name === "zxmlType" || tag.tagSignature === "CxF ") {
            // Try decompress and parse XML
            let bytes = parsed.compressedData || parsed.bytes;
            if (bytes) {
              try {
                const inflated = pako.inflate(bytes, { to: 'string' });
                // Try parse XML and render as tree
                let xmlTree = null;
                try {
                  const parser = new DOMParser();
                  const xmlDoc = parser.parseFromString(inflated, "application/xml");
                  xmlTree = renderXMLTree(xmlDoc.documentElement);
                } catch (e) {
                  xmlTree = `<pre>${inflated}</pre>`;
                }
                parsed.decompressedXML = xmlTree;
              } catch (e) {
                parsed.decompressedXML = "Ошибка распаковки: " + e;
              }
            }
          }
            // Special handling for matrix3x3Type (e.g., chad)
            if (schema && schema.name === 'matrix3x3Type') {
              try {
                if (window.renderMatrix3x3) parsed.__html = window.renderMatrix3x3(parsed);
              } catch (e) {
                // ignore render errors
              }
            }


          // Special handling for text-like tags (textType, descType, cprt, DevD)
          let formattedText = null;
          if (schema && schema.name === 'textType' && parsed.text) formattedText = parsed.text;
          else if (schema && schema.name === 'descType' && parsed.asciiString) formattedText = parsed.asciiString;
          else if (parsed && parsed.asciiString) formattedText = parsed.asciiString;
          else if (parsed && parsed.text) formattedText = parsed.text;
          // If we found text content, render as escaped preformatted block
          if (formattedText !== null) {
            const clean = window.sanitizeText ? window.sanitizeText(formattedText) : String(formattedText).trim();
            const esc = window.escapeHTML ? window.escapeHTML(clean) : String(clean);
            parsedTags[tagTitle] = { text: `<pre style='background:#fff;color:#222;padding:10px;border-radius:5px;white-space:pre-wrap;'>${esc}</pre>` };
          } else {
            parsedTags[tagTitle] = parsed;
          }
        } catch (err) {
          parsedTags[tagTitle] = { error: String(err), rawHex: api_formatHexDump(new Uint8Array(buffer, tag.offset, tag.size), tag.offset) };
        }
      } else {
  parsedTags[tagTitle] = { rawHex: api_formatHexDump(new Uint8Array(buffer, tag.offset, tag.size), tag.offset) };
      }
    }

    const result = { Header: header, Tags: parsedTags };
    const out = document.getElementById('output');
    out.innerHTML = '';
  out.appendChild(api_renderTree(result, file.name, true));
  };
  reader.readAsArrayBuffer(file);
});


// Use pickSchema from parse.js
const api_pickSchema = (tagSig, view, offset) => window.pickSchema(tagSig, view, offset, schemaMap, schemaResolved);


// Use resolveSchema from parse.js
const api_resolveSchema = (key) => window.resolveSchema(key, schemaMap, schemaResolved);


// Use parseBySchema from parse.js
const api_parseBySchema = (view, schema, startOffset=0, ctx={}) => window.parseBySchema(view, schema, startOffset, ctx);


// Use readAscii from utils.js
const api_readAscii = (view, off, len) => window.readAscii(view, off, len);


// Use formatHexDump from utils.js
const api_formatHexDump = (uint8arr, base=0) => window.formatHexDump(uint8arr, base);


// Use renderTree from view.js
const api_renderTree = (obj, label, isRoot=false) => window.renderTree(obj, label, isRoot);
</script>
</body>
</html>
